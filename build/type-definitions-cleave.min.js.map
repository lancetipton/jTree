{"version":3,"sources":["webpack://[name]/./src/scripts/modules/types/definitions/cleave/index.js"],"names":["getCleaveEl","Editor","id","schema","component","getElementsByClassName","Values","CLEAVE_CLS","CleaveType","config","_this","_classCallCheck","this","_getPrototypeOf","call","_defineProperty","_assertThisInitialized","e","cleave","element","console","warn","update","value","target","rawValue","key","getAttribute","DATA_SCHEMA_KEY","original","classList","contains","NUMBER_CLS","numVal","Number","isNaN","undefined","expandOnChange","setWidth","userEvents","onChange","updated","domNode","cleaveOpts","onValueChanged","onCleaveChange","clearCleave","Cleave","setRawValue","Array","from","getElementsByTagName","map","input","checkCleave","oninput","rmOpts","arguments","length","destroy","clearObj","props","mode","Schema","MODES","EDIT","buildEvents","parent","instance","_objectWithoutProperties","_objectSpread","BaseType"],"mappings":"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","file":"type-definitions-cleave.min.js","sourcesContent":["import BaseType from '../base'\nimport Cleave from 'cleave.js'\nimport { clearObj } from 'jTUtils'\nimport { Values, Schema } from 'jTConstants'\n\nconst getCleaveEl = (Editor, id) => {\n  const schema = Editor.schema(id)\n  return schema &&\n    schema.component &&\n    schema.component.getElementsByClassName(Values.CLEAVE_CLS)[0]\n}\n\nclass CleaveType extends BaseType {\n\n  constructor(config){\n    super(config)\n    this.cleaveOpts = {\n      onValueChanged: this.onCleaveChange,\n      ...config.cleave,\n    }\n  }\n  \n  onCleaveChange = (e, Editor) => {\n    // Sometimes this method gets called before the cleave is initialized\n    // So if no cleave, but return \n    if(!this.cleave) return\n    // If there is no cleave element, then just return\n    // this method should never have been called\n    if(!this.cleave.element)\n      return console.warn(`Called onCleaveChange but no cleave element exists`, this)\n\n    const update = {\n      value: e.target.rawValue,\n      key: this.cleave.element.getAttribute(Values.DATA_SCHEMA_KEY),\n      original: this.original.value\n    }\n\n    // Check if the input should be a number\n    if(this.cleave.element.classList.contains(Values.NUMBER_CLS)){\n      const numVal = Number(update.value)\n      // If it's a valid number use that instead\n      !isNaN(numVal) && (update.value = numVal)\n    }\n\n    // Ensure we have a valid key and value, and there was an update\n    if(\n      (update.value === undefined || update.key === undefined) ||\n      (this.original[update.key] && this.original[update.key] === update.value)\n    ) return\n\n    this.config.expandOnChange !== false &&\n      this.setWidth(getCleaveEl(Editor, this.original.id))\n\n    return this.original.value !== update.value &&\n      this.userEvents.onChange(e, update, this.original.id, Editor) !== false &&\n      (this.updated.value = update.value)\n  }\n\n  checkCleave = (schema, domNode) => {\n    if(domNode.classList && domNode.classList.contains(Values.CLEAVE_CLS)){\n      // Set the onValueChanged cb here, so we get access to the injected Editor\n      this.cleaveOpts.onValueChanged = this.onCleaveChange\n      // If a cleave instance already exists, clear it out\n      this.cleave && this.clearCleave()\n      // Create a new cleave instance, with the current domNode\n      this.cleave = new Cleave(domNode, this.cleaveOpts)\n      // Set the initial cleave value\n      this.cleave.setRawValue(schema.value)\n      return true\n    }\n  }\n  \n  buildEvents = (schema, domNode) => (\n    domNode && Array\n      .from(domNode.getElementsByTagName('input'))\n      .map(input => {\n        // Checks if it has the cleave class\n        // Catches changes for the key input\n        !this.cleave && this.checkCleave(schema, input)\n          ? (domNode.oninput = undefined)\n          : (domNode.oninput = this.onChange)\n\n        this.config.expandOnChange !== false && this.setWidth(input)\n      })\n  )\n\n  clearCleave = (rmOpts=true) => {\n    if(!this.cleave) return\n    this.cleave.destroy()\n    this.cleave = undefined\n    rmOpts && clearObj(this.cleaveOpts)\n  }\n\n  componentDidUpdate = (props, Editor) => {\n    const { schema } = props\n    // If not in edit mode, clear out cleave\n    if(schema.mode !== Schema.MODES.EDIT) this.clearCleave(false)\n    // If in edit mode, and no cleave, add the cleave to the component\n    else if(!this.cleave) this.buildEvents(schema, schema.component)\n    // Else update the cleave to the current raw value\n    else this.cleave.setRawValue(schema.value)\n    \n    const { parent, instance, component, ...original } = schema\n    // Update original with current schema\n    this.original = original\n    // Clear out the updated, because we just updated\n    this.updated && clearObj(this.updated)\n  }\n  \n  componentWillUnmount = (Editor) => {\n    // Set to undefined, because when the instance gets remove, we don't want it \n    // to remove the value; it's a ref to the actual value in the tree\n    this.original.value = undefined\n    this.clearCleave()\n  }\n\n}\n\nexport default CleaveType"],"sourceRoot":""}