((typeof self !== 'undefined' ? self : this)["webpackJsonp_name_"] = (typeof self !== 'undefined' ? self : this)["webpackJsonp_name_"] || []).push([["render-js-dispatcher"],{

/***/ "./src/scripts/modules/renders/js/dispatcher.js":
/*!******************************************************!*\
  !*** ./src/scripts/modules/renders/js/dispatcher.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clonedeep */ "./node_modules/lodash.clonedeep/index.js");
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__);
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


var WATCHERS = {};
var ON_DISPATCH;
var STATE;

var isFunc = function isFunc(test) {
  return typeof test === 'function';
};

var destroy = function destroy() {
  return Object.entries(WATCHERS).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        id = _ref2[0],
        cbs = _ref2[1];

    cbs && cbs.map(function (cb) {
      return cb && typeof cb.destroy === 'function' && cb.destroy(id);
    });
    WATCHERS[watcher] = undefined;
    delete WATCHERS[watcher];
  });
};

var dispatch = function dispatch(id) {
  if (!ON_DISPATCH) return console.warn("You must create a store before you can dispatch to it");

  for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    payload[_key - 1] = arguments[_key];
  }

  return update(ON_DISPATCH.apply(void 0, [STATE, id].concat(payload)), id);
};

var create = function create(onDispatch, state) {
  if (ON_DISPATCH || STATE) return console.warn("dispatcher.create should only be call once for an application");
  if (!onDispatch || !isFunc(onDispatch)) return console.warn("dispatcher.create requires an 'onDispatch' method");
  if (!state || (typeof store === "undefined" ? "undefined" : _typeof(store)) !== 'object') return console.warn("create requires an initial state of type 'object'");
  ON_DISPATCH = onDispatch;
  STATE = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0___default()(state);
  return STATE;
};
/**
 * Checks the state for an update, and updates when needed
 * Calls all cbs linked to the passed in id
 * @param  {any} updatedState - new changes
 * @param  {any} id - used to find the linked callbacks
 * @param  {any} key - used to find the location of the state that was updated
 * @return { void }
 */


var update = function update(updatedState, id) {
  // If no updated state, or the current state is equal to the update state
  // No update, so just return
  if (!updatedState || STATE === updatedState) return STATE; // Otherwise update the state with the updateState param

  STATE = _objectSpread({}, STATE, updatedState);
  var cbs = WATCHERS[id];
  cbs && cbs.length && cbs.map(function (cb) {
    return typeof cb === 'function' && cb(STATE);
  });
  return STATE;
};

var watch = function watch(id, cb) {
  if (!cb || typeof cb !== "function") console.warn("You must pass a function as the second argument to store.listen()");
  WATCHERS[id] = WATCHERS[id] || [];
  WATCHERS[id].push(cb);
};

var getWatchers = function getWatchers() {
  return WATCHERS;
};

var forget = function forget(id, cb) {
  if (!id || !WATCHERS[id]) console.warn("You must pass and id to forget a watcher");
  var cbIndex = WATCHERS[id].indexOf(cb);
  cbIndex !== -1 && WATCHERS[id].splice(cbIndex, 1);
};

var dispatcher = {
  create: create,
  destroy: destroy,
  dispatch: dispatch,
  forget: forget,
  getWatchers: getWatchers,
  watch: watch,
  update: update
};
/* harmony default export */ __webpack_exports__["default"] = (dispatcher);

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvc2NyaXB0cy9tb2R1bGVzL3JlbmRlcnMvanMvZGlzcGF0Y2hlci5qcyJdLCJuYW1lcyI6WyJXQVRDSEVSUyIsIk9OX0RJU1BBVENIIiwiU1RBVEUiLCJpc0Z1bmMiLCJ0ZXN0IiwiZGVzdHJveSIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJpZCIsImNicyIsImNiIiwid2F0Y2hlciIsInVuZGVmaW5lZCIsImRpc3BhdGNoIiwiY29uc29sZSIsIndhcm4iLCJwYXlsb2FkIiwidXBkYXRlIiwiY3JlYXRlIiwib25EaXNwYXRjaCIsInN0YXRlIiwic3RvcmUiLCJjbG9uZURlZXAiLCJ1cGRhdGVkU3RhdGUiLCJsZW5ndGgiLCJ3YXRjaCIsInB1c2giLCJnZXRXYXRjaGVycyIsImZvcmdldCIsImNiSW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiZGlzcGF0Y2hlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQSxJQUFNQSxRQUFRLEdBQUcsRUFBakI7QUFDQSxJQUFJQyxXQUFKO0FBQ0EsSUFBSUMsS0FBSjs7QUFDQSxJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBUyxDQUFBQyxJQUFJO0FBQUEsU0FBSSxPQUFPQSxJQUFQLEtBQWdCLFVBQXBCO0FBQUEsQ0FBbkI7O0FBQ0EsSUFBTUMsT0FBTyxHQUFHLFNBQVZBLE9BQVU7QUFBQSxTQUNkQyxNQUFNLENBQ0hDLE9BREgsQ0FDV1AsUUFEWCxFQUVHUSxHQUZILENBRU8sZ0JBQWdCO0FBQUE7QUFBQSxRQUFkQyxFQUFjO0FBQUEsUUFBVkMsR0FBVTs7QUFDbkJBLE9BQUcsSUFBSUEsR0FBRyxDQUFDRixHQUFKLENBQVEsVUFBQUcsRUFBRTtBQUFBLGFBQUlBLEVBQUUsSUFBSSxPQUFPQSxFQUFFLENBQUNOLE9BQVYsS0FBc0IsVUFBNUIsSUFBMENNLEVBQUUsQ0FBQ04sT0FBSCxDQUFXSSxFQUFYLENBQTlDO0FBQUEsS0FB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QjtBQUNELENBTkQ7O0FBUUEsSUFBTUcsVUFBVSxHQUFHO0FBQ2pCZCxRQUFNLEVBQU5BLE1BRGlCO0FBRWpCZCxTQUFPLEVBQVBBLE9BRmlCO0FBR2pCUyxVQUFRLEVBQVJBLFFBSGlCO0FBSWpCZSxRQUFNLEVBQU5BLE1BSmlCO0FBS2pCRCxhQUFXLEVBQVhBLFdBTGlCO0FBTWpCRixPQUFLLEVBQUxBLEtBTmlCO0FBT2pCUixRQUFNLEVBQU5BO0FBUGlCLENBQW5CO0FBVWVlLHlFQUFmLEUiLCJmaWxlIjoicmVuZGVyLWpzLWRpc3BhdGNoZXIubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2guY2xvbmVkZWVwJ1xuXG5jb25zdCBXQVRDSEVSUyA9IHt9IFxubGV0IE9OX0RJU1BBVENIXG5sZXQgU1RBVEVcbmNvbnN0IGlzRnVuYyA9IHRlc3QgPT4gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbidcbmNvbnN0IGRlc3Ryb3kgPSAoKSA9PiAoXG4gIE9iamVjdFxuICAgIC5lbnRyaWVzKFdBVENIRVJTKVxuICAgIC5tYXAoKFtpZCwgY2JzXSkgPT4gIHtcbiAgICAgIGNicyAmJiBjYnMubWFwKGNiID0+IGNiICYmIHR5cGVvZiBjYi5kZXN0cm95ID09PSAnZnVuY3Rpb24nICYmIGNiLmRlc3Ryb3koaWQpKVxuICAgICAgV0FUQ0hFUlNbd2F0Y2hlcl0gPSB1bmRlZmluZWRcbiAgICAgIGRlbGV0ZSBXQVRDSEVSU1t3YXRjaGVyXVxuICAgIH0pXG4pXG5jb25zdCBkaXNwYXRjaCA9IChpZCwgLi4ucGF5bG9hZCkgPT4ge1xuICBpZighT05fRElTUEFUQ0gpXG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihgWW91IG11c3QgY3JlYXRlIGEgc3RvcmUgYmVmb3JlIHlvdSBjYW4gZGlzcGF0Y2ggdG8gaXRgKVxuXG4gIHJldHVybiB1cGRhdGUoXG4gICAgT05fRElTUEFUQ0goU1RBVEUsIGlkLCAuLi5wYXlsb2FkKSxcbiAgICBpZFxuICApXG59XG5cbmNvbnN0IGNyZWF0ZSA9IChvbkRpc3BhdGNoLCBzdGF0ZSkgPT4ge1xuICBpZihPTl9ESVNQQVRDSCB8fCBTVEFURSlcbiAgICByZXR1cm4gY29uc29sZS53YXJuKGBkaXNwYXRjaGVyLmNyZWF0ZSBzaG91bGQgb25seSBiZSBjYWxsIG9uY2UgZm9yIGFuIGFwcGxpY2F0aW9uYClcbiAgICBcbiAgaWYoIW9uRGlzcGF0Y2ggfHwgIWlzRnVuYyhvbkRpc3BhdGNoKSlcbiAgICByZXR1cm4gY29uc29sZS53YXJuKGBkaXNwYXRjaGVyLmNyZWF0ZSByZXF1aXJlcyBhbiAnb25EaXNwYXRjaCcgbWV0aG9kYClcbiAgaWYoIXN0YXRlIHx8IHR5cGVvZiBzdG9yZSAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihgY3JlYXRlIHJlcXVpcmVzIGFuIGluaXRpYWwgc3RhdGUgb2YgdHlwZSAnb2JqZWN0J2ApXG5cbiAgT05fRElTUEFUQ0ggPSBvbkRpc3BhdGNoXG4gIFNUQVRFID0gY2xvbmVEZWVwKHN0YXRlKVxuICByZXR1cm4gU1RBVEVcbn1cblxuLyoqXG4gKiBDaGVja3MgdGhlIHN0YXRlIGZvciBhbiB1cGRhdGUsIGFuZCB1cGRhdGVzIHdoZW4gbmVlZGVkXG4gKiBDYWxscyBhbGwgY2JzIGxpbmtlZCB0byB0aGUgcGFzc2VkIGluIGlkXG4gKiBAcGFyYW0gIHthbnl9IHVwZGF0ZWRTdGF0ZSAtIG5ldyBjaGFuZ2VzXG4gKiBAcGFyYW0gIHthbnl9IGlkIC0gdXNlZCB0byBmaW5kIHRoZSBsaW5rZWQgY2FsbGJhY2tzXG4gKiBAcGFyYW0gIHthbnl9IGtleSAtIHVzZWQgdG8gZmluZCB0aGUgbG9jYXRpb24gb2YgdGhlIHN0YXRlIHRoYXQgd2FzIHVwZGF0ZWRcbiAqIEByZXR1cm4geyB2b2lkIH1cbiAqL1xuY29uc3QgdXBkYXRlID0gKHVwZGF0ZWRTdGF0ZSwgaWQpID0+IHtcbiAgLy8gSWYgbm8gdXBkYXRlZCBzdGF0ZSwgb3IgdGhlIGN1cnJlbnQgc3RhdGUgaXMgZXF1YWwgdG8gdGhlIHVwZGF0ZSBzdGF0ZVxuICAvLyBObyB1cGRhdGUsIHNvIGp1c3QgcmV0dXJuXG4gIGlmKCF1cGRhdGVkU3RhdGUgfHwgU1RBVEUgPT09IHVwZGF0ZWRTdGF0ZSlcbiAgICByZXR1cm4gU1RBVEVcblxuICAvLyBPdGhlcndpc2UgdXBkYXRlIHRoZSBzdGF0ZSB3aXRoIHRoZSB1cGRhdGVTdGF0ZSBwYXJhbVxuICBTVEFURSA9IHsgLi4uU1RBVEUsIC4uLnVwZGF0ZWRTdGF0ZSB9XG5cbiAgY29uc3QgY2JzID0gV0FUQ0hFUlNbaWRdXG4gIGNicyAmJlxuICAgIGNicy5sZW5ndGggJiZcbiAgICBjYnMubWFwKGNiID0+IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyAmJiBjYihTVEFURSkpXG4gIFxuICByZXR1cm4gU1RBVEVcbn1cblxuY29uc3Qgd2F0Y2ggPSAoaWQsIGNiKSA9PiB7XG4gIGlmICghY2IgfHwgdHlwZW9mIGNiICE9PSBgZnVuY3Rpb25gKVxuICAgIGNvbnNvbGUud2FybihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gc3RvcmUubGlzdGVuKClgKVxuXG4gIFdBVENIRVJTW2lkXSA9IFdBVENIRVJTW2lkXSB8fCBbXVxuICBXQVRDSEVSU1tpZF0ucHVzaChjYilcbn1cblxuY29uc3QgZ2V0V2F0Y2hlcnMgPSAoKSA9PiBXQVRDSEVSU1xuXG5jb25zdCBmb3JnZXQgPSAoaWQsIGNiKSA9PiB7XG4gIGlmKCFpZCB8fCAhV0FUQ0hFUlNbaWRdKVxuICAgIGNvbnNvbGUud2FybihgWW91IG11c3QgcGFzcyBhbmQgaWQgdG8gZm9yZ2V0IGEgd2F0Y2hlcmApXG5cbiAgY29uc3QgY2JJbmRleCA9IFdBVENIRVJTW2lkXS5pbmRleE9mKGNiKVxuICBjYkluZGV4ICE9PSAtMSAmJiBXQVRDSEVSU1tpZF0uc3BsaWNlKGNiSW5kZXgsIDEpO1xufVxuXG5jb25zdCBkaXNwYXRjaGVyID0ge1xuICBjcmVhdGUsXG4gIGRlc3Ryb3ksXG4gIGRpc3BhdGNoLFxuICBmb3JnZXQsXG4gIGdldFdhdGNoZXJzLFxuICB3YXRjaCxcbiAgdXBkYXRlXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoZXIiXSwic291cmNlUm9vdCI6IiJ9